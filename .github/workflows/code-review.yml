# Automated Code Review Workflow for GitHub Actions
# Add this file to .github/workflows/code-review.yml in your repository

name: Automated Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run ESLint
        run: |
          if [ -f "package.json" ]; then
            npm ci || npm install
            npx eslint . --format json > eslint-report.json || true
          fi
        continue-on-error: true

      - name: Run Security Audit
        run: |
          if [ -f "package.json" ]; then
            npm audit --json > audit-report.json || true
          fi
        continue-on-error: true

      - name: Analyze Complexity
        run: |
          node -e "
            const fs = require('fs');
            const path = require('path');

            function findFiles(dir) {
              const files = [];
              const entries = fs.readdirSync(dir, { withFileTypes: true });
              for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
                  files.push(...findFiles(fullPath));
                } else if (entry.isFile() && /\.(js|jsx|ts|tsx)$/.test(entry.name)) {
                  files.push(fullPath);
                }
              }
              return files;
            }

            const findings = [];
            const files = findFiles('.');
            for (const file of files) {
              const content = fs.readFileSync(file, 'utf8');
              const lines = content.split('\n').length;
              if (lines > 500) {
                findings.push({ file, type: 'long-file', lines });
              }
              const functions = content.match(/function\s+\w+|const\s+\w+\s*=\s*\(/g) || [];
              if (functions.length > 20) {
                findings.push({ file, type: 'many-functions', count: functions.length });
              }
            }

            fs.writeFileSync('complexity-report.json', JSON.stringify(findings, null, 2));
          "
        continue-on-error: true

      - name: Generate Review Comment
        run: |
          node -e "
            const fs = require('fs');

            let eslintFindings = [];
            let auditFindings = [];
            let complexityFindings = [];

            if (fs.existsSync('eslint-report.json')) {
              eslintFindings = JSON.parse(fs.readFileSync('eslint-report.json', 'utf8'));
            }
            if (fs.existsSync('audit-report.json')) {
              auditFindings = JSON.parse(fs.readFileSync('audit-report.json', 'utf8'));
              auditFindings = auditFindings.vulnerabilities ? Object.values(auditFindings.vulnerabilities) : [];
            }
            if (fs.existsSync('complexity-report.json')) {
              complexityFindings = JSON.parse(fs.readFileSync('complexity-report.json', 'utf8'));
            }

            const comment = '## ðŸ” Automated Code Review\n\n';
            comment += '### ðŸ“Š Summary\n\n';

            const lintCount = eslintFindings.reduce((sum, f) => sum + f.messages.length, 0);
            comment += '- **Lint Issues:** ' + lintCount + '\n';
            comment += '- **Security Issues:** ' + auditFindings.length + '\n';
            comment += '- **Complexity Issues:** ' + complexityFindings.length + '\n\n';

            if (lintCount > 0) {
              comment += '### ðŸ”§ Linting\n\n';
              eslintFindings.slice(0, 5).forEach(f => {
                f.messages.slice(0, 3).forEach(m => {
                  comment += '- ' + f.filePath + ':' + m.line + ' - ' + m.message + '\n';
                });
              });
              if (eslintFindings.length > 5) {
                comment += '\n...and more\n';
              }
              comment += '\n';
            }

            if (auditFindings.length > 0) {
              comment += '### ðŸ”’ Security\n\n';
              auditFindings.slice(0, 5).forEach(v => {
                comment += '- ' + v.name + ' (' + v.severity + '): ' + (v.title || 'Unknown') + '\n';
              });
              if (auditFindings.length > 5) {
                comment += '\n...and more\n';
              }
              comment += '\n';
            }

            if (complexityFindings.length > 0) {
              comment += '### ðŸ“ Complexity\n\n';
              complexityFindings.slice(0, 5).forEach(f => {
                if (f.type === 'long-file') {
                  comment += '- ' + f.file + ': ' + f.lines + ' lines (consider splitting)\n';
                } else {
                  comment += '- ' + f.file + ': ' + f.count + ' functions (consider splitting)\n';
                }
              });
              if (complexityFindings.length > 5) {
                comment += '\n...and more\n';
              }
              comment += '\n';
            }

            comment += '\n---\n*Generated by Automated Code Review*';
            fs.writeFileSync('review-comment.txt', comment);
          "

      - name: Post Comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('review-comment.txt', 'utf8');

            // Find existing bot comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Automated Code Review')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }
